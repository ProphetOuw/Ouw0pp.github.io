{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Context","text":"<p>This documenetation will help you learn how certain frameworks work. You might of been redirected here because you have been appointed(or are working with a frontend scripter) with the goal of implementing skills directely into the game's framework.</p>"},{"location":"#payments","title":"Payments","text":"<p>Payment availability</p> <p>Payments are available in robux, but not always in USD. If you prefer USD, you should ask if the option is available.</p>"},{"location":"#front-end-payment","title":"Front-end payment","text":"<p>Front end developers will get paid 190K per skill. If you are working with someone, this can be split in whatever manner you prefer</p> <p>advice against half assing</p> <p>If some directions are ignored you won't be paid the full amount, instead some deductions will be taken. This will only happen if we warn you countless times and the changes aren't made.</p>"},{"location":"#skill-implementation-payment","title":"Skill-implementation payment","text":"<p>If you are also a front end developer, these payments will be given ontop of the payment stated in the previous block.</p>"},{"location":"#rates","title":"Rates","text":"<ul> <li>14,285 Robux or $50 - Easy skill</li> <li>28,571 Robux or $100 - Medium Skill</li> <li>42,857 Robux or $150 - Hard Skill</li> </ul> <p>The difficulty in which a skill is assumed may change before or after the implementation is done, And it may change depending on the amount of work you'd have to do. If you are provided with resources, this may change the assumed difficulty.</p>"},{"location":"#code-cleanelyness-bonus-4","title":"Code cleanelyness Bonus($ * #/4 )","text":"<ul> <li>7,143 Robux or $25 - Decent code</li> <li>21,428 Robux or $75 - Super clean and good code</li> </ul> <p>The individual that'll determine the level of cleanelyness for your code may be yourself(If you have shown to be knowledgeable) or someone within Ouw Productions who has been appointed to do so.</p>"},{"location":"#gameplay-consideration-bonus","title":"Gameplay consideration Bonus","text":"<ul> <li>0 Robux or $0 - No consideration/left it up to someone else</li> <li>14,286 Robux or $50 - Minor changes need to be made to your code in order to adjust it for gameplay</li> <li>28,571 Robux or $100 - Skill is good gameplay wise</li> </ul>"},{"location":"#additional-bonusesonly-ouw-can-hand-you-these","title":"Additional Bonuses(ONLY OUW CAN HAND YOU THESE)","text":"<p>If not given to you, if you think you deserve it you can get up to:</p> <ul> <li>28,571 Robux or $100</li> <li>57,143 Robux or $200</li> <li>85,714 Robux or $300</li> </ul> <p>As additional bonuses on a moveset. A 28,571 Robux - 57,143 Robux bonus, or its equivalence in usd will be given to all of the skills of your first moveset.</p>"},{"location":"backend/","title":"Skill backend framework/Skill articulation","text":""},{"location":"backend/#reminders","title":"Reminders","text":"<ul> <li>IF YOU ARE TO RESKIN ANY SKILL YOU MUST TAKE THEM FROM THE MAIN PLACES, NOT THE DEV PLACES.</li> <li>Make sure tables within skill storage are cleared consistently, you don't want to use past data on new occurences.</li> <li>All align positions, or any body movers that may disrupt the updrafting functions must be named \"air_combo_bp\" so that the scripts delete them prior to updrafting.</li> <li>Updrafting functions are  not limited to updrafting, they are a good way to maintain a entity floating mid air by setting a custom Y position, the function will return an attachment which u can delete when needed to.</li> <li>Strict Stun can only be added through a skill's stats, unless you set noautomation to true, it is the 5th parameter of combatutitlity:AddStun or combatutility:Add_Strict_Stun.</li> <li>Updrafting should go through regardless of if the target's blocking or not.</li> <li>Add simple repetitive vfx functions(Emit,delete,etc) into the vfxutility if not there already and use them from that module. This module SHOULD ONLY BE EDITED IN DX MAIN PLACE THEN PUBLISHED.</li> <li>There is free admin in studio, the prefix for it is double tap <code>;</code>.</li> <li>Pressing E on ur keyboard stuns you and this should trigger skill canceling, you can use this to test canceling for skills.</li> <li>Q + A,W,S, or D to dash, this can also help you test skill behaviour.</li> <li>Sound volume should range from 50 to 250, if you're not sure a safe number is 200.</li> </ul>"},{"location":"backend/#getting-skills-ready","title":"Getting Skills Ready","text":"<p>Search \u201cCharacter_Profiles\u201d in the search bar, this module lets you add skills in so that they can work on the framework.</p> <p>Once you open this module, it should look something like this</p> <p>This is how the skill sets/movesets are set up. If you are to add your own moveset you'd add the following dicitonary element in the \"configs\" table Within Character_Profiles module<pre><code>[\"Example Moveset\"] = {\n        {\n            Name = \"Skill 2\";\n            CoolDown = 1;\n            icon = \"not important/leave blnak\";\n            Max_Hold = 4;\n            Skill_Stats = { --important later/delete if you are copying this from the doc\n                Invisibility = true;\n                stun_bypass_skill = true;\n            }\n        };\n        {\n            Name = \"Skill 2\";\n            CoolDown = 1;\n            icon = \"not important/leave blank\";\n            Max_Hold = 3;\n            Skill_Stats = { --important later/delete if you are copying this from the doc\n                Invisibility = true;\n                Counter = 2;\n            }\n        };\n}\n</code></pre></p> <p>Skills_Stats</p> <p>Ignore Skill_Stats right now, it will help us with important backend modules/skill behaviour later.</p> <p>To equip said moveset to be tested you change the default index in the skillset variable within the character_profile module to correspond with the moveset index(or module name), you can also set it to be unique to you by making the index your username.</p> <p>After that the skills should now be in the framework and ready to be tested/used.</p>"},{"location":"backend/#custom-charactersweapons-for-movesets","title":"Custom characters/weapons for movesets","text":"<p>You can also use custom starter characters for movesets, just rename the animation rig to the index of the moveset and parent it into the folder below...</p>"},{"location":"backend/#setting-up-skills-modules","title":"Setting up skills modules","text":"<p>All of the skills come with a pair of modules, one for the client and the other for the server, these modules are parented within the \"Skills\" folder within game.ReplicatedStorage.Cam</p> <p>As you can see, there exists child folders within the \u201cSkills\u201d folder, the system does not take the folders into account, it uses GetDescendants() to get all the module scripts, therefor you can nest folder within folder, module within module, it does not matter. For skills to work there must exist two module scripts, you will copy past the \u201cTemplate\u201d and \u201cTemplateServer\u201d modules and name them according to the skill name. \u201cTemplate\u201d becomes \u201c[insert skill name]\u201d, this is the client module. \u201cTemplateServer\u201d becomes \u201c[insert skill name]Server\u201d, this is the server module.The template scripts contain all the functions that get called by the skill framework, the ones commented out are not mandatory. The other ones that are not commented out(Hold,Unhold, and Cancel) are mandatory unless stated otherwise. The following code shows the contents of the client module Within client script<pre><code>local module = {Id = 0}\nfunction module:Hold(plr,mouseposition)\n    print(\"hold block for \",plr)\nend\nfunction module:UnHold(plr,mouseposition)\n    print(\"Unhold for \",plr.Name)\nend\nfunction module:Cancel(plr,mouseposition)\n    print(\"Cancel block for \",plr.Name)\nend\n\n\n--[[ -- Optional. runs after the skill has been ran on the server\nfunction module:After_Server_Hold_Signal(plr)\n\nend\nfunction module:Toggle(plr,mouseposition,counterie) --toggle skill(Uses RS&gt;Cam&gt;Global&gt;Subsets&gt;Gameplay&gt;SkillPassiveToggleSignal)\n    print(\"client tog\")\nend\nfunction module:After_Server_Unhold_Signal(plr)\n\nend\nfunction module:After_Server_Cancel_Signal(plr)\n\nend\nfunction module:After_Server_Counter_Signal(plr)\n\nend\n\nfunction module:Counter(plr,mouseposition,counterie) --counter skill(Uses skill stats)\nend\nfunction module:Switch(plr) -- player flip switch function(Uses RS&gt;Cam&gt;Global&gt;Subsets&gt;Gameplay&gt;Skill_Switch_Adder)\n\nend\n\n]]\nreturn module\n</code></pre> The id variable within the module, changes everytime the state of the skill changes, so it's different when the skill is held,unheld, or canceld. You can use that id to do some important checks in the Hold function. The following is the code within the server module Within the server module for skill<pre><code>local module = {Id = {}}\nfunction module:Hold(plr,mouseposition)\n    print(\"hold block for \",plr)\nend\nfunction module:UnHold(plr,mouseposition)\n    print(\"Unhold for \",plr.Name)\nend\nfunction module:Cancel(plr,mouseposition,HitHoldLimit)\n    print(\"Cancel block for \",plr.Name)\nend\n\n--[[-- Optional. runs after the skill has been ran on the server\nfunction module:Switch(plr) --player switch function\n\nend\nfunction module:Toggle(plr) --toggle function --dodging etc\n    print(plr.Name,\" dodge\")\nend\nfunction module:Counter(plr,mouseposition,counterie) --counter skill\nend\n]]\nreturn module\n</code></pre> As you can see here, the Id variable's value is a table instead of a numeric value. This is because multiple players use the same module on the server, so to get the Id for a specific player you'd get it like this: <pre><code>local Id = module.Id[plr]\n</code></pre> The server and client skill module will be ran simultaneously by the framework</p> <p>Everything will be explained later</p> <p>I know i haven't shown a way to continiously get the mouseposition, nor have i explained the functions that are commented out, those will be explained later in this page.</p>"},{"location":"backend/#some-dos-and-donts-in-the-client-module","title":"Some Do's and Don'ts in the client module","text":"<ul> <li>You can create bodymovers on the client, as long as they are deleted in the Unhold or Cancel function. But if the bodymover propells the character up or down, it is recommended that you do that using the updrafting functions.</li> <li>You can loop in the client modules, but the loop must have an end condition</li> <li>You Can't fire or receive signals from remote events or remote functions within the client effects modules(There is another way to achieve server/client communication, this will be shown later)</li> <li>You can require and use any module that is available to the client as long as recursion doesn't happen</li> </ul>"},{"location":"backend/#some-dos-and-donts-in-the-server-module","title":"Some Do's and Don'ts in the server module","text":"<ul> <li>You can't create bodymovers for the player on the server, there are certain modules that will allow you to do knockbacks, updrafting,etc.</li> <li>You can't receive or fire remote events or remote functions(There are exists a specific way to achieve server/client communication)</li> <li>You can add body movers in victims as long as it lasts as long as their stun, if it's a body mover with the goal of changing their Y position somehow, use the updrafting functions which will be showcased later</li> </ul>"},{"location":"backend/#sending-signals-to-client-to-perform-skill-effects","title":"Sending signals to client to perform skill effects","text":""},{"location":"backend/#from-server","title":"From server","text":"<p><pre><code>game.ReplicatedStorage.Communication.SnC.Effects.RE:FireAllClients(\"effect module name\",param1,param2,...,paramn)\n</code></pre> or <pre><code>game.ReplicatedStorage.Communication.SnC.Effects.RE:FireClient(plr,\"effect module name\",param1,param2,...,paramn)\n</code></pre> The \"RE\" stands for \"Remote Event\" you can switch out to \"RF\" which stands for \"remote function\", this will tell the client to fire the modules created in the front-end framework</p>"},{"location":"backend/#from-client","title":"From client","text":"<pre><code>game.ReplicatedStorage.Communication.CnC.ClientEffects:Fire(\"effect module name\",param1,param2,...,paramn)\n</code></pre>"},{"location":"backend/#preventing-2-players-hitting-each-other-at-oncehit-priority-handler","title":"Preventing 2 players hitting each other at once(Hit priority handler)","text":"<p><pre><code>local hit_priority_handler = game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Game_Play\"):WaitForChild(\"hit_priority_handler\")\n--assume some victimvalues,and playervalues variables exist.\nlocal initiated = hit_priority_handler:New(script) --initiates the hit priority for the script\n\ninitiated:Exists(victimvalues,\"choosing\") --checks if a value named \"choosing exists in the victim values\n\ninitiated:Add(plrvalues,\"choosing\",.1) --adds a value in the playervalues folder for .1 seconds, this value grants an iframe like behaviour for skills that do the \"Exists\" check.\n\ninitiated:Both(vicvalues,_settings: {lifetime: constant , name: string,add: boolean})\n\n--Example use case:\nfor i,v in pairs(models) do\n   if hit_priority_handler.Both(vicvalues,{pv = plrvalues,name = \"Choosing_1\"}) == true then continue end;\n   --v has no priority since the \"Choosing_1\" value does not exist inside of vicvalues\nend\n</code></pre> The initiated.Both(...) function first checks if the value exists in the victim , if it does then, it returns true letting the script know that the victim/target has priority, if it doesn't exist then it adds the value into _settings.pv(if it hasn't already been added)which is the player  folder, letting every other attacker know that the player has priority.</p> <p>The importance of this procedure/module</p> <p>This module prevents players hitting each other at once, which helps the combat feel good. It is mandatory in most if not all skills</p>"},{"location":"backend/#forcing-a-skill-actionholdunholdcancel","title":"Forcing a skill action(Hold,Unhold,Cancel)","text":"<p>Hold Will only work if there are no other skills being held, and will work like a tap. unHold and Cancel will only work if said skill is being held. Some server script<pre><code>game.ReplicatedStorage.Communication.SnC.Effects.RE:FireClient(plr,\"force_skill_actions_server\",\"skillname(Case sensitive)\",\"Cancel\",cooldown: boolean, replicate: boolean)\n--cooldown helps you control wether or not the skill will have a cooldown. It is recommended to just leave this blank\n--replicate param helps you control wether or not the action gets replicated to the server, this is recommended to be left blank as well, in which case it would replicate to the server, this is so you woudn't have to do any special measures on the server like setting the ids manuelly/\n</code></pre> As you can see this uses the same remote i use to fire effects to play. The frontend skill effects framework is not limited to skill effects.</p>"},{"location":"backend/#use-case","title":"Use case","text":"<p>Lets say you made a rasengan skill, it's a tap to activate, then you will add a loop that will run for a couple of seconds so that the \"Hold\" state stays on the client, u want the hold to be terminated if the player is stunned or if the timer runs out on the server, if you want to tell/force the client to unhold the skill you'd fire this.</p>"},{"location":"backend/#getting-player-mouse-position-on-the-client","title":"Getting player mouse position on the client","text":"<p>This is for getting an updated mouse position in a loop of some kind as the mouse position is already sent in the parameter Some client script<pre><code>local ph = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Client\"):WaitForChild(\"Controllers\"):WaitForChild(\"Platform_Handler\"))\n\nlocal mouse_pos = ph:mousepos(max depth(Optional))\n</code></pre></p>"},{"location":"backend/#getting-mouse-position-on-the-server","title":"Getting mouse position on the server","text":"<p>This is tricky because it uses both the server and the client module script. It creates a part on the server that the player has network ownership over, Then in the client module, that part's position is updated to the mouse position, since the player has network ownership over it, the position will also be updated on the server.</p>"},{"location":"backend/#step-1-creating-the-part-on-server-script","title":"Step 1: Creating the part on server script","text":"<p>We can create the part using the following module in the following way Some skill server script<pre><code>local SM = require(game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Services\"):WaitForChild(\"Server_Mouse_Pos\"))\n\nSM:Create_Pos_Part(Character,name of the part,max existence duration)\n</code></pre> Now we can access the part on both server or client with <pre><code>local PP = character:FindFirstChild(\"PosPart\".. name of the part ..\"Server\")\nprint(PP.Position)\n</code></pre></p>"},{"location":"backend/#step-2-updating-the-parts-position-on-client","title":"Step 2: Updating the part's position on client","text":"<p>To update it on the client you'd run the following code in a loop <pre><code>local PP = character:FindFirstChild(\"PosPart\".. name of the part ..\"Server\")\nif PP ~= nil then\n    PP.Position = mouse_pos\n    PP.bp.Position = mouse_pos\n    --i have a alignposition in it, i set the align position(PP.bp.Position) after setting the position of the part just to be safe, because body movers always replicate\nend\n</code></pre></p>"},{"location":"backend/#step-3-deleting-the-part","title":"Step 3: Deleting the part","text":"<p>You can either let the duration run out, and the part auto deletes itself or delete it yourself by running <pre><code>local SM = require(game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Services\"):WaitForChild(\"Server_Mouse_Pos\"))\nSM:Delete_Pos_Part(Character,name of the part)\n</code></pre></p>"},{"location":"backend/#projectile-skills-guide","title":"Projectile skills guide","text":"<p>Projectiles are done using shape casting or touched, up to you. You would create an invisible projectile on the server, then on the client do the same exact calculations, with same velocities, and starting position, but this time it will be the actual projectile. When a hit is registered on the client, all it will do is play the collision effect, on the server you will cast a hitbox when the invisible projectile's collision is registered. YOU MAY DO THIS YOUR OWN WAY, BUT U MUST ALWAYS INCLUDE THE METHOD BELOW WITH PROJECTILES(Checker module method).</p> <p>Important note</p> <p>If you're using touched, raycasting, or shapecasting to register a projectile collision, if that collision belongs to a Humanoid, make sure you check if that humanoid is available by using the checker module, if the return isn't nil then u can register the collision. This must be done in both client(Subjective) and server collisions</p> <pre><code>local results = workspace:Blockcast(CFF,newBird.Size * 1.35,newBird.CFrame.LookVector*20,hitParams)\nif results ~= nil and results.Instance ~= nil then\n    hit = results.Instance\n\n    local distance = (results.Position - newBird.Position).Magnitude\n    Intersect = CFrame.lookAlong(newBird.Position + newBird.CFrame.LookVector * (distance - newBird.Size.Z * 0.5), newBird.CFrame.LookVector)\nend\nif hit ~= nil then\n    local victim = Utility:find_character_from_descendant(hit) -- does a couple repetitions until it gets to a humanoid from the child\n    if victim == nil then return/continue end;\n    if victim and victim == character then return/continue end;tring) -&gt;\n    --** IMPORTANT\n    if checker:check_victim(script.Parent:GetFullName(),character,victim) == nil then return/continue end;\n    --**\nend\n</code></pre>"},{"location":"backend/#debris-module-deleting-destroying","title":"Debris module / deleting / destroying","text":"<p>I have a custom module that replaces debris and acts as a destroyer <pre><code>local DebrisModule = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"DebrisModule\"))\nDebrisModule:AddItem(item,duration)\n</code></pre> Here's the source code for the module for you to use, do not add this code into any of the effects module or skill modules(require it instead). I already have this module. <pre><code>local mod = {\n  Debris = {}\n}\nfunction mod:Clean(item)\n    if mod.Debris[item] then\n        task.cancel(mod.Debris[item])\n    end\nend\nfunction mod:AddItem(item,duration)\n    if item == nil then return end;\n    self:Clean(item)\n    self.Debris[item] = task.delay(duration or 5,function()\n        if item ~= nil then\n            item:Destroy()\n        end\n    end)\nend\nreturn mod\n</code></pre></p>"},{"location":"backend/#timed-serverclient-skill-communication-portal","title":"Timed server/client skill communication portal","text":"<p>I have created a module, that lets u create a server client communication portal that lasts a set duration, this could be used during skills, it can also remove some purpose from the force skill action mechanic. The portal must be created on the server in the following manner Some server script<pre><code>local ServerClientLink = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"ServerClientLink\"))\nlocal Event,Send,Remove = ServerClientLink:New(plr,string: conneciton name,int: connection duration)\nEvent:Connect(function(param1,param2,...,paramn)\n    --do something with the signal received from the client\nend)\nSend(yield (true for function, false for event),param1,param2,...,paramn) --send signal to client\ntask.wait(5)\nRemove() --delete the signal, this will automatically be done after the duration\n</code></pre></p> <p>Note</p> <p>The \"Remove\" variable is only available on the server</p> <p>On the client Some client script<pre><code>local ServerClientLink = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"ServerClientLink\"))\nlocal Event,Send = ServerClientLink:Connect(String: conneciton name, int: conneciton duration)\nEvent:Connect(function(param1,param2,...,paramn)\n    --do something with the signal received from server\nend)\nSend(param1,param2,...,paramn) -- send signal to server\n</code></pre></p> <p>Note</p> <p>You should check if Event and Send exist on the client prior to using them, incase the connection is unsuccessful</p> <p>You can also remove a connection by name(Only on server) Some script on the server<pre><code>local ServerClientLink = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"ServerClientLink\"))\nServerClientLink:RemoveLink(plr,String: connection name)\n</code></pre></p>"},{"location":"backend/#skill-stats","title":"Skill Stats","text":"<p>Some skills will have some properties, such as iframes, counter,etc. If we go back to the \"Getting skills ready\" header we can now put this to use In Character_Profiles<pre><code>[\"Example Moveset\"] = {\n        {\n            Name = \"Skill 2\";\n            CoolDown = 1;\n            icon = \"not important/leave blnak\";\n            Max_Hold = 4;\n            Skill_Stats = {\n                Invisibility = true;\n                stun_bypass_skill = true;\n            }\n        };\n        {\n            Name = \"Skill 2\";\n            CoolDown = 1;\n            icon = \"not important/leave blank\";\n            Max_Hold = 3;\n            Skill_Stats = {\n                Invisibility = true;\n                Counter = 2;\n            }\n        };\n}\n</code></pre> Here are description of some skill stats <pre><code>--[[current properties\n    Cancel_Bypass=true --makes it so the skill can't be canceld when stunned,ragdolled,etc\n\n   stun_bypass_skill=true --makes it so you can perform the skill while being stunned\n    skills_to_play_over = {} --list skills that this will play over no matter what\n\n   iframe = can be any value as long as it exists\n\n   invisibility= can be any value as long as it exists, turns character invisible and undetecctable\n\n   Block_Pierce --this is read only, notifies skill stats that this skill ignores block but does not damage while blocking\n\n   Strict_Stun --gives the skill a strict stun meaning victims are disabled from doing anything, regular stun has some exceptions, strict stun doesn't.\n\n   Counter = 1,2,3 -- 1 = combat, 2 = everything, 3 = skills only\n\n   transparent = can be any value as long as it exists, turns the character invisible but it can be detected by npcs,etc.\n]]\n</code></pre></p> <p>Important</p> <p>I use string.lower on all of these, so wether u write stuff in upper or lower case is irrelevant.</p>"},{"location":"backend/#counter-skills","title":"Counter skills","text":"<p>You setup a counter by having the property \"Counter\" in its skill stats In Character_Profiles<pre><code>[\"Example Moveset\"] = {\n        {\n            Name = \"counter skill\";\n            CoolDown = 1;\n            icon = \"not important/leave blank\";\n            Max_Hold = 3;\n            Skill_Stats = {\n                Counter = 2;\n            }\n        };\n}\n</code></pre> Then when the counter is trigured, the \"Counter\" function in both the server and client module of the skill, will be fired with the expected parameters.</p>"},{"location":"backend/#creating-remote-controlled-skills","title":"Creating remote controlled skills","text":"<p>Skills that u initiate and then toggle later, like a landmine skill that u can explode later. Some server skill module<pre><code>local skill_switch = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Subsets\"):WaitForChild(\"Gameplay\"):WaitForChild(\"Skill_Switch_Adder\"))\nlocal object = skill_switch:Add(plr, switch name, Duration(Optional?))\n\n--add a any value(boolean,string,etc) with the name \"Disabled\" within the object to disable it.\n</code></pre> This will create a noticeable effect on the button icon, when that button is pressed again the \"Switch\" function will be fired on the server and client module. If duration is not specified, it will assume a default value.</p>"},{"location":"backend/#skill-passive-toggling","title":"Skill passive toggling","text":"<p>Used for more than one toggling of the skill, triggered by different cases but not controlled by the player. This can be used if a skill activates a certain amount of dodges like ken haki. Some server skill module<pre><code>local PassiveToggleSignal = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Subsets\"):WaitForChild(\"Gameplay\"):WaitForChild(\"SkillPassiveToggleSignal\"))\n\nPassiveToggleSignal:New(character,skillname,setting: {int: Duration(Optional?),int(Optional?): Type})\n</code></pre> Here are the types of passive toggling</p> <p>I use the \"Menum\" medoule because i like it,but it is optional you can just pass the corresponding numeric  instead. When the skills are triggered the \"Toggle\" function within the client and server skill scripts will be fired. If duration is not specified, it will assume a default value.</p>"},{"location":"backend/#a-signaler-for-cancelingnot-limited-to-skills-framework","title":"A signaler for canceling(Not limited to skills framework)","text":"<p>Skills are only cancelable while the hold state is running, if the unhold or cancel state is being ran, then the skill is considered ran and can not be canceld or unheld anymore, so when we have yields in our cancel or unhold functions, we use the ManuelCancel module to pick up canceling signals. In Some server or client script<pre><code>local cancelsignal,canceldestroy = manuelCancel:New(character,int: duration(Optional))\ncancelsignal:Connect(function()\n    --do something\nend)\ntask.wait(pos1)\ncanceldestroy()\n</code></pre> If duration is not specified, it will assume a default value. calling the canceldestroy variable is optional, it is automatically called after the duration is completed</p> <p>Note</p> <p>this module can be ran outside of the skill framework, and can be ran on both the client and server.</p>"},{"location":"backend/#casting-a-hitbox","title":"Casting a hitbox","text":"<p>You can cast a hitbox using one of the functions in the utility module Some script<pre><code>--&lt; casting the hit box\nlocal Models = Utility:GetModelInRegion(CFrame: cf,vector3: Size,string: custom tag name(Optional),max parts(Optional))\n--&lt;using the models captured\nfor i,v in pairs(Models) do\n   do\n        if v ~=character and v:FindFirstChild(\"Humanoid\") ~= nil then\n            local vicroot,vhum = v:FindFirstChild(\"HumanoidRootPart\"),v:FindFirstChild(\"Humanoid\")\n        end\n    end\nend\n</code></pre> There is also a hitbox casting function that does most of the work for you, it wraps the GetModelInRegion function. <pre><code>local hitDetected = function(target: Model, target, targetState: 'Blocking' | 'Perfect' | true)\n    local targetHumanoid = target:FindFirstChild('Humanoid') :: Humanoid\n    local targetRoot = targetHumanoid.RootPart :: BasePart\n    --\n    local targetAnimator = targetHumanoid:FindFirstChild('Animator')\n\n    if targetState == 'Perfect' then\n        combatUtility:Perfect(script:GetFullName(), character, target)\n    elseif targetState == 'Blocking' then\n        combatUtility:Block(script:GetFullName(), character, target, BLOCK_DAMAGE)\n    elseif targetState == true then\n\n    end\nend\n\n--\nutility:CreateHitbox({\n    caster = character,\n\n    hitboxSize = HITBOX_SIZE, --size\n    hitboxCFrame = goal, --center\n\n    hitPriorityHandler = {callback = hitPriorityHandler.Both, data = { pv = characterValues, name = 'Choosing_1' }}, --mandatory\n    checker = checker, -- checker module\n\n    hitDetected = hitDetected --function to fire pe4r target\n})\n</code></pre> It does priority checks, and lets you customize it more so that ur code is cleaner.</p>"},{"location":"backend/#checking-if-a-captured-enemy-is-damageable","title":"Checking if a captured enemy is damageable","text":"<p>You must use the checker module to check if a captured enemy is damageable <pre><code>local checker = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Checker\"))\nlocal result = checker:check_victim(script:GetFullName(),character/caster character,victim)\n</code></pre> result can either be:</p> <ul> <li>True: This means everything is good to go</li> <li>Perfect: The caster got perfect blocked</li> <li>Block: The victim is blocking</li> <li>nil: This means do not do anything to the victim</li> </ul> <p>A caster is not expected to damage itself, so when u run this function on the caster themselves, you must add a 4th parameter telling the function to disregard the self damaging iframe otherwise it will always return nil <pre><code>local checker = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Checker\"))\nlocal result = checker:check_victim(script:GetFullName(),character/caster character,character/caster character,{iframe = true})\n</code></pre></p>"},{"location":"backend/#damagingstunning-etc","title":"Damaging,Stunning etc","text":"<p>These methods are done with the help of the Combat_Util module, that is only available on the server <pre><code>local combat_util = require(game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Services\"):WaitForChild(\"Combat_Util\"));\nCombat_Util:Block(script:GetFullName(),character,v,block_remove)\nCombat_Util:AddStun(script:GetFullName(),character,vicvalues,1.5)\nCombat_Util:RagDoll(script:GetFullName(),character,vicvalues,1.5)\nCombat_Util:Damage(script:GetFullName(),character,v,{Base = dmg ,Skill = script.Parent.Name})\n--v is the victim\n--vicvalues is the values folder for the victim\n</code></pre> These functions can be used on the caster without other considerations.</p> <p>Note</p> <p>Values folders are where i store values for the player, npcs,etc. I use values alot to depict states, send signals,etc. It is not part of the skill framework so ignore it for now.</p> <p>To get the value folder of a player or npc u use the function <pre><code>local Utility = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Utility\"))\nvicvalues = Utility:getvaluesfolder(plrcharacter or npc/victim character)\n</code></pre></p>"},{"location":"backend/#skill-storage","title":"Skill Storage","text":"<p>A storage for serversided module scripts for skills, This can only be used on the server as creating unmanaged tables within the server module script for a skill is prohibited. <pre><code>local skillStorage = require(game.ServerStorage.SAM.Utility.SkillStorage)\n--When u want to access a storage table for a skill\nlocal storageTable = SkillStorage:GetID(plr,skillname)\n--Empty the table\nlocal storageTable = SkillStorage:ResetId(plr,skillname)\n--When ur done with it\nSkillStorage:ClearID(plr, skillname)\n</code></pre> By default, the skill storage for a skill will be the last parameter on the server functions, the framework will automatically create it for you, This table is unique to the player(Other players can't access it). It is cleared when the player leaves, otherwise you'd have to clean it manuelly. It is available on the Hold, unhold, and cancel function. You may print it to test if it is there, if a table is printed then it is there. Remember that the second parameter is always the player's mouse position.</p> <p>Please Remember</p> <p>Special functions like counters and toggles will not always have this at the third parameter. When you are cleaning the table manuelly, you can't set skillstorage = {}, since this is just a reference, when you do this you are referencing it to a new table, You must instead require the SkillStorage module in serverstorage and run :ResetId like it is shown in the code snippet above.</p>"},{"location":"backend/#getting-a-skills-statuslast-used-or-if-its-being-used","title":"Getting a skill's status(Last used, or if it's being used)","text":"<p><pre><code>local manage_cd = require(game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Game_Play\"):WaitForChild(\"manage_cd\"))\nlocal lastUsed,isBeingUsed = manage_cd:skillStatus(plr,string: skill name) \n</code></pre> You can use this on remote toggle or passive toggle skills to measure the last time said skill was used.</p>"},{"location":"backend/#the-importance-of-pause-gameplay-valuefunction-yielding","title":"The importance of pause gameplay value/function yielding","text":"<p>When the character is not able to do anything(combat,dash,cast skills) this is called \"paused gameplay\". This happens when the player is holding a skill or when a player unholds a skill and there are yields in the unhold function. When the aren't any yields u can exhibit the same behaviours by adding a value named \"pause_gameplay\" in the player values, this will ensure that the player is not able to dodge,combat,etc while a sequence of event is still happening in the unhold function. Example<pre><code>local plrvalues = Utility:getvaluesfolder(character)\nlocal pause_gameplay = Instance.new(\"BoolValue\")\npause_gameplay.Name = \"pause_gameplay\"\npause_gameplay.Parent = plrvalues\nDebrisModule:AddItem(pause_gameplay,1.4)\n\n--or\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"Cam\"):WaitForChild(\"Global\"):WaitForChild(\"Utility))\nUtility:AddValue(parent: Instance, name: string, duration: number)\n</code></pre></p>"},{"location":"backend/#more-helpful-values","title":"More helpful values","text":""},{"location":"backend/#skillslow-value","title":"skillslow value","text":"<p>This value sets the player's walkspeed to 4. <pre><code>local DebrisModule = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"DebrisModule\"))\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Utility\"))\nplrv = Utility:getvaluesfolder(plrcharacter or npc/victim character)\nlocal skils = Instance.new(\"BooleanValue\")\nskils.Name = \"skillslow\"\nskils.Parent = plrv\nDebrisModule:AddItem(skils,2)\n\n--or\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"Cam\"):WaitForChild(\"Global\"):WaitForChild(\"Utility))\nUtility:AddValue(parent: Instance, name: string, duration: number)\n</code></pre></p>"},{"location":"backend/#fov-valuesetting-custom-field-of-view-to-the-camera","title":"FOV Value/Setting custom FIELD OF VIEW to the camera","text":"<pre><code>local DebrisModule = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"DebrisModule\"))\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Utility\"))\nplrv = Utility:getvaluesfolder(plrcharacter or npc/victim character)\nlocal FOV = Instance.new(\"IntValue\")\nFOV.Name = \"FOV\"\nFOV.Value = 70;\nFOV.Parent = plrv\nDebrisModule:AddItem(FOV,2)\n--This value also accepts a \"Priority\" attribute in the case of overlapping. The higher the priority the more it is prioritized over other FOV values in the same values folder.\n--or\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"Cam\"):WaitForChild(\"Global\"):WaitForChild(\"Utility))\nUtility:AddValue(parent: Instance, name: string, duration: number)\n</code></pre>"},{"location":"backend/#skill_stand_still-value","title":"skill_stand_still value","text":"<p>This value sets the player's walkspeed to 0. <pre><code>local DebrisModule = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"DebrisModule\"))\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Utility\"))\nplrv = Utility:getvaluesfolder(plrcharacter or npc/victim character)\nlocal skill_stand_still = Instance.new(\"BooleanValue\")\nskill_stand_still.Name = \"skill_stand_still\"\nskill_stand_still.Parent = plrv\nDebrisModule:AddItem(skill_stand_still,2)\n\n--or\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"Cam\"):WaitForChild(\"Global\"):WaitForChild(\"Utility))\nUtility:AddValue(parent: Instance, name: string, duration: number)\n</code></pre></p>"},{"location":"backend/#nomouvementlines-value","title":"NOMouvementlines value","text":"<p>This value disables the movement lines. <pre><code>local DebrisModule = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"DebrisModule\"))\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Utility\"))\nplrv = Utility:getvaluesfolder(plrcharacter or npc/victim character)\nlocal NOMouvementlines = Instance.new(\"BooleanValue\")\nNOMouvementlines.Name = \"NOMouvementlines\"\nNOMouvementlines.Parent = plrv\nDebrisModule:AddItem(NOMouvementlines,2)\n\n--or\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"Cam\"):WaitForChild(\"Global\"):WaitForChild(\"Utility))\nUtility:AddValue(parent: Instance, name: string, duration: number)\n</code></pre></p>"},{"location":"backend/#nr-value-disable-auto-rotate","title":"NR value / disable auto rotate","text":"<p>This value disables auto rotation, so the player's rotation will be locked. <pre><code>local DebrisModule = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"DebrisModule\"))\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"Global\"):WaitForChild(\"Utility\"))\nplrv = Utility:getvaluesfolder(plrcharacter or npc/victim character)\nlocal NR = Instance.new(\"BooleanValue\")\nNR.Name = \"NR\"\nNR.Parent = plrv\nDebrisModule:AddItem(NR,2)\n\n--or\nlocal Utility = require(game.ReplicatedStorage:WaitForChild(\"Cam\"):WaitForChild(\"Global\"):WaitForChild(\"Utility))\nUtility:AddValue(parent: Instance, name: string, duration: number)\n</code></pre></p>"},{"location":"backend/#how-to-know-if-a-skill-was-unheld-due-to-being-held-for-the-maximum-amount-of-time","title":"How to know if a skill was unheld due to being held for the maximum amount of time","text":"<p>Setting the varialbe in a skill's data(not skill stat, skill data) will make it so the third parameter is true if expired cuz the skill reached its max hold time or nil if the player unheld the key. having this feature enabled for your skill(s) pushes the skillstorage to the 4th parameter.</p>"},{"location":"backend/#updrafting","title":"Updrafting","text":"<p>Many skills will have the ability to propell a player, or a player and the victim being attacked into the air, we use two other functions within Combat_Util to achieve this.</p>"},{"location":"backend/#updrafting-one-entity","title":"Updrafting one entity","text":"<pre><code>local combat_util = require(game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Services\"):WaitForChild(\"Combat_Util\"));\ncombat_util:Add_air_combo_bp(target_root,character_root(optional but mandatory for network setting),custom_y(Optional),startpos(Optional/X and Z are ignored))\n--startpos is the ground position\n--customy is the distance from the ground\n</code></pre>"},{"location":"backend/#updrafting-two-entities","title":"Updrafting two entities","text":"<p><pre><code>local combat_util = require(game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Services\"):WaitForChild(\"Combat_Util\"));\ncombat_util:Air_combo_up(caster character,victim character)\n</code></pre> This does a regular updraft on the caster character and victim character, it is used in combat, and many existing skills.</p>"},{"location":"backend/#cutscene-skills","title":"Cutscene skills","text":"<p>Since not every cutscene skills will be casted similarly i will only explain the process of after it connects.</p> <ul> <li>Get the cframe of where it connected.</li> <li>Cast a hitbox(If necessary) and loop through all the captured victims</li> <li>Create invisible anchored parts that will be cframed according to the animation in which you will weld the caster and the victim, they must be on two or more seperate parts that respect the animation initial positioning. Each entity/target will have its own part so that when one dies they don't all die.</li> <li>Make sure you aren't creating the caster's anchored part within the loops,if you do, then add sanity checks to make sure it only creates one part</li> <li>Add Stuns,iframes,pause_gameplay values that'll last the length of the cutscene, you will give them max existence duration and delete them when necessary.</li> <li>Play the animaiton for both the caster and the victim</li> <li>Get the camera rig, play animation on it, then use the camera module to stick the player and victim's cameras to the animaiton rig <pre><code>local cutscene_handler = require(game.ServerStorage:WaitForChild(\"SAM\"):WaitForChild(\"Game_Play\"):WaitForChild(\"Cutscene_camera_handler\"))\nif Cam == nil then\n    Cam = script.CameraRig:Clone()\n    Cam:PivotTo(root.CFrame)\n    Cam.Parent = workspace.Debree\n    Cam.RootPart.RootPart.Part0 = root\n    game.Debris:AddItem(Cam,1.73)\n    Cam.AnimationController.Animator:LoadAnimation(script.glock_cam_thing):Play()\n    do\n        cutscene_handler:Regular(plr,Cam.Bone)\n    end\nend\nif Cam ~= nil then\n    --getting the victim if its a player so that we can play the camera animation to it too\n    local pr = game.Players:GetPlayerFromCharacter(v)\n    if pr then\n        cutscene_handler:Regular(pr,Cam.Bone)\n    end\nend\n</code></pre></li> </ul> <p>Note</p> <p>I will provide a ton of skill examples, don't worry... After reading the doc, you will understand the skill code easily.</p>"},{"location":"backend/#long-dash-skills","title":"Long dash skills","text":"<p>These are done by running a hitbox on the server continiously, then when the hitbox finally hits something, you force the skill to be unheld, then remove or tween the body movers on client to stop while doing a capture action on the server. Most of the time the dash can also be stopped by the player unhold the skill.</p>"},{"location":"backend/#reference-skills","title":"Reference skills","text":"<p>I have left a folder within game.ReplicatedStorage.Cam.Skills with reference skills, do not reuse or reference any skills that aren't in this folder.</p>"},{"location":"frontend/","title":"Front end frame-work","text":"<p>If you're only assignment is to make the frontend for a specific skill or moveset, this is most likely as far as you will need to read.</p>"},{"location":"frontend/#important-notes","title":"Important notes","text":"<ul> <li>Pressing E on ur keyboard stuns you and this should trigger skill canceling, you can use this to test canceling for skills.</li> <li>Q + A,W,S, or D to dash, this can also help you test skill behaviour.</li> <li>Sound volume should range from 50 to 250, if you're not sure a safe number is 200.</li> <li>Effect modules should contain effects and only effects, you will not maneuver or do anything with the character in the effects modules, that\u2019s to be done in a separate script.</li> <li>Front end developers must follow the front end layout/instructions listed in this page</li> <li>If you do not have access to the group inventory, you will upload animations/sounds to your own inventory. If you are uploading animations, make sure to leave the keyframe sequence within the animation instance so that we may reupload it to the Ouw productions group.</li> <li>No replacing functions that roblox already provides you for custom ones(Debris, math, etc...)</li> </ul> <ul> <li>Make sure the sounds have max distances, if ur not sure what to set it to, Set it to 200.</li> </ul>"},{"location":"frontend/#effect-modules-placementfor-front-endsback-ends-working-with-the-op-framework","title":"Effect modules placement(For Front-ends/Back-ends working with the OP framework)","text":"<p>Effect modules are to be placed in the folder called \"Effets\" in replicated storage. Wether you choose to put them in a already existing folder, or create a folder for a new set of skills does not matter and is up to you. But if you are working on a new moveset, it is strongly recommended that you create a new folder for said moveset.</p> <p>OP framework</p> <p>The acronym \"OP\" stands for \"Ouw Productions\"</p>"},{"location":"frontend/#debris-module-deleting-destroying","title":"Debris module / deleting / destroying","text":"<p>I have a custom module that replaces debris and acts as a destroyer <pre><code>local DebrisModule = require(game.ReplicatedStorage:WaitForChild(\"CAM\"):WaitForChild(\"DebrisModule\"))\nDebrisModule:AddItem(item,duration)\n</code></pre> Here's the source code for the module for you to use, do not add this code into any of the effects module or skill modules(require it instead). I already have this module. <pre><code>local mod = {\n  Debris = {}\n}\nfunction mod:Clean(item)\n    if mod.Debris[item] then\n        task.cancel(mod.Debris[item])\n    end\nend\nfunction mod:AddItem(item,duration)\n    if item == nil then return end;\n    self:Clean(item)\n    self.Debris[item] = task.delay(duration or 5,function()\n        if item ~= nil then\n            item:Destroy()\n        end\n    end)\nend\nreturn mod\n</code></pre></p>"},{"location":"frontend/#effect-module-instructions","title":"Effect module instructions","text":"<p>The name of the module should correlate with the skill in which it is for.</p> <p>Does the name require to match the skill name</p> <p>No it does not, this is only to help differentiate it from the other module scripts</p>"},{"location":"frontend/#setup","title":"Setup","text":"<p>Each skill module will return a function which will accept necessary parameters. Modules such as the camera shaker or crater module should be required on top of the script.</p> <p>Inside the Fireball effects module<pre><code>return function(character,state)\n    --do stuff\nend)\n</code></pre> You will have to parent your effects in some folder, if you are working with the OP framework, you will create such folder Creating of the effects debree folder<pre><code>local Effects = workspace.Debree:FindFirstChild(game.Players.LocalPlayer.Name..\"'s effects debree thing213asdasdasdasd\")\nif Effects == nil then\n    Effects = Instance.new(\"Folder\",workspace.Debree)\n    Effects.Name = game.Players.LocalPlayer.Name..\"'s effects debree thing213asdasdasdasd\"\nend\n</code></pre> If you aren't working with the OP framework, just create some random folder in workspace, name it accordingly, make it so it would be easier for us to replace that instance code block with the one above.</p>"},{"location":"frontend/#streaming-enabled","title":"Streaming enabled","text":"<p>This game uses streaming enabled for better performance. This means that you don't send basepart instances within ur parameters to the client module, you have to wait for those parts(with a max wait time) from a model parent(Because models don't get streamed out) and then check if they exist. In Fireball client effect module<pre><code>return function(character,state)\n    local projectile = character:WaitForChild(\"ProjectileParentModel\",2)\n    if projectile == nil then return end;\n    projectile = projectile:FindFirstChild(\"MainPart\")\n    if projectile == nil then return end; -- this may be repeated at different parts of the code to prevent erroring.\n\n    --do stuff\n\nend)\n</code></pre> For parts that are within the character that is casting a skill, or that aren't created by the server skill script, you must not use waitforchild for them, you can just directely check if they exist. In Fireball client effect module<pre><code>return function(character,state)\n    local root = character:FindFirstChild(\"HumanoidRootPart\")\n    if root == nil then return end;\n\n    --do stuff\n\nend)\n</code></pre></p>"},{"location":"frontend/#effects-helpers-and-utility-modules","title":"Effects helpers and utility modules","text":"<p>Camera shaker, and crater module will be provided to you(None OP framework), these are one of the only modules you shall require within the effects modules.  If you want to use other modules, for OP framework, check if that module you want already exists in the following folder(Different crater modules are within the \"Craters\" folder)</p> <p>If it does not exist in here and the module is a utility module or has independent functions, you can just copy those functions over to the effects module and use them accordingly. If the funcitons are dependent within the module, and you'd need to copy over the entire module in order to make use of it, you shoud let us know if you are using OP framework and we'll implement it in for you after scanning the module, if you aren't a OP framework user, then just place the module somewhere in replicatedstorage and require it.</p> <p>Note</p> <p>We already have tons of popular modules available within our frameworks(This is only relevant to OP framework users)</p>"},{"location":"frontend/#distance-checking","title":"Distance checking","text":"<p>Distance checking is really important, because if a player is too far we don\u2019t want to play effects on their client. Within the Fireball effects module<pre><code>return function(player,direction)\n    --**------------**--\n    if (plr.Character.HumanoidRootPart.Position-workspace.CurrentCamera.CFrame.Position).Magnitude &gt;= 250 then return end;\n    --**------------**--\nend\n</code></pre> If the skill you\u2019re working on has states you may want to disregard the distance check when a cancel state is fired. Still within the Fireball effects module<pre><code>return function(player,state,direction)\n    --**------------**--\n    if (plr.Character.HumanoidRootPart.Position-workspace.CurrentCamera.CFrame.Position).Magnitude &gt;= 250 and state ~= \"cancel\" then\n        --Do cleanup logic in here incase the distance is above 250 and the state isn't \"cancel\", if you don't do this then the effects will just be stuck in the world forever.\n     return end;\n    --**------------**--\nend\n</code></pre></p> <p>Note</p> <p>Proper sanity checks to ensure that all the parameters that are needed exist should be done beforehand. if we account for streaming enabled, make sure that instances passed within your parameters are not mandatory to run the cancel state.</p>"},{"location":"frontend/#approach-to-canceable-skill-effects","title":"Approach to canceable skill effects","text":"<p>Although there are many ways a cancelable skill can be done, I prefer this simple approach instead, if you have any suggestions, run them by me first.</p> <p>Important Info</p> <p>Skills with many states, and no yields may not require a cancelation procedure. If a yield in the effects doesn't last too long, you shall perform the cancel procedure after the duration is completed. If you are disabling effects first, make sure to rename the folder so that if the skill was used twice and it is being canceld for the second time, FindFirstChild doesn't get the same folder.</p> Within the Fireball effects module<pre><code>return function(player,character,state)\n    local itemname = \"canceled##\"..plr.Name..plr.UserId --make sure the name is unique so that it doesn't cancel for other players\n    if state == \"Startup\" then\n        local effects = Instance.new(\"BoolValue\")\n        effects.Name = itemname\n        effects.Parent = workspace;\n        game.debris:AddItem(effects,10) --really important to have a max existence time for the item so that some bug doesn't cause it to stay there forever\n    elseif state == \"Cancel\" then\n        local item = workspace:FindFirstChild(itemname)\n        if item then\n            --[[you might want to disable particles first, then delete the item after some time.\n            If you're going to do this, name the item \"--\" or something that won't cause it to be picked up everytime the cancel state is ran,\n            we only want it to be canceled once incase a player performs the skill again while the old item is being canceled]]\n            item:Destroy()\n        end\n    end \nend\n</code></pre> <p>WHY DO IT LIKE THIS??</p> <p>If you use tables, and other single state methods, this will make it so that if the skill is used multiple times, it only cancels one occurrence.</p> <p>if you want to make sure it cancels previous effects before any state is ran, you can do this like this(Notice how the cancel code block is ran before any state checks) Within Fireball module<pre><code>return function(player,character,state)\n    local itemname = \"canceled##\"..plr.Name..plr.UserId --make sure the name is unique so that it doesn't cancel for other players\n    do--&lt;cancel\n        local item = workspace:FindFirstChild(itemname)\n        if item then\n            --[[you might want to disable particles first, then delete the item after some time.\n            If you're going to do this, name the item \"--\" or something that won't cause it to be picked up everytime the cancel state is ran,\n            we only want it to be canceled once incase a player performs the skill again while the old item is being canceled]]\n            item:Destroy()\n        end\n    end--&gt;\n    if state == \"Startup\" then\n        local effects = Instance.new(\"BoolValue\")\n        effects.Name = itemname\n        effects.Parent = workspace;\n        game.debris:AddItem(effects,10) --really important to have a max existence time for the item so that some bug doesn't cause it to stay there forever\n    end \nend\n</code></pre></p> <p>IMPORTANT REMINDER</p> <p>PLEASE KEEP IN MIND THAT NO BODY-MOVERS OR ANY SORT OF MANEUVERING OR MODIFICATION SHALL BE DONE TO THE PLAYER/NPC CHARACTER WITHIN THE EFFECTS MODULES UNLESS STATED OTHERWISE. The effects modules are purely to play effects and nothing else!</p>"}]}